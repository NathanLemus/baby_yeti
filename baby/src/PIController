#!/usr/bin/env python

#Need to do conversion so we can compare encoder feedback with setpoint made by controller
#Need to set up proper update() function so that it suits the robot
#Need to determine if the sabertooth code needs to be implemented
#Need to determine how many times PID must be called for one Setpoint (how many function calls for a left turn?)
#Need to determine if function is too intensive for Jetson (Nate fan disapproves)

import time
import math
import rospy #for talker/ listener
from geometry_msgs.msg import Twist #for talker/ listener
from geometry_msgs.msg import Int64 #??? i check later
import matplotlib.pyplot as plt
from simple_pid import PID

class Motor:
    #we need to take in controller input for setpoint
    #we need to take in encoder ticks, find linear speed (current state)
    #essentially make motor go brr in a smooth manner (purr)

    def __init__(self):
        self.speed = 0

    def update(self, effort, dt): # effort is result of pid function
        if effort > 0:
            # change speed in attempt to match setpoint
            self.speed += 1 * effort * dt
        return self.speed


def controlInputCallback(msg): #from sabertooth
    x = msg.linear.x      # -1 < x < 1
    z = msg.angular.z * 2 # -1 < z < 1
    left, right = twistToWheelSpeed(x, z)
    sendWheelSpeedToMotors(left, right)


def twistToWheelSpeed(x, z): #from sabertooth
    if z > 0.2:
	#left
	if z > 0.9:
        	left = z
        	right = -1 * z
	else:
		left = z
        	right = x * z * -1
    elif z < -0.2:
	#right
        if z < -0.9:
		left = z
        	right = -1 * z
	else:
		left = x
        	right = x * z * -1
    else:
        left, right = x, x
    return left, right


def sendWheelSpeedToMotors(left, right): #from sabertooth
    leftChr = (64+((127*left)/2))
    rightChr = (64+((127*right)/2))+128 # it can go faster going left
    leftint = int(leftChr)
    if leftint == 0:
        leftint = 1
    rightint = int(rightChr)
    #these integer values will be the setpoint for the PI Controller


def encoderCallback(msg):
    #(0,~180) rpms converted to (1,127)
    #Y=0.7055x+1

    leftChannel = msg.data
    #rightChannel = #?????
    m = 0.7055
    b = 1
    leftVel = (m*leftChannel+b)
    #rightVel = (m*rightChannel+b)


def PIController(leftInt, rightInt, leftVel, rightVel):
    #setpoint for left and right controller inputs
    #actual values from encoder rpms
    #perform PI work to generate desired work for system to perform
    #take the stuff from main


if __name__ == '__main__':
    motor = Motor()
    speed = motor.speed

    pid = PID(5, 0.01, 0, setpoint=speed)#don't need a value for D
    pid.output_limits = (0, 100)

    start_time = time.time()
    last_time = start_time

    # keep track of values for plotting
    #setpoint, y, x = [], [], []

    #add callback for controller input
    #add callback for encoder ticks
    rospy.init_node('PIController', anonymous=True)
    rate = rospy.Rate(30)
    rospy.Subscriber("/manual_control_vel", Twist, controlInputCallback)
    rospy.Subscriber("/encoderticks", Int64, encoderCallback) #check if float is correct
    rospy.spin()


    #FINISH
    while time.time() - start_time < 10:
        current_time = time.time()
        dt = current_time - last_time

        power = pid(speed) #do we need to change power here?
        speed = motor.update(power, dt) #do we need to change power here?

        x += [current_time - start_time]
        y += [speed]
        setpoint += [pid.setpoint]

        if current_time - start_time > 1:
            pid.setpoint = 100  ##########

        last_time = current_time


    #plt.plot(x, y, label='measured')
    #plt.plot(x, setpoint, label='target')
    #plt.xlabel('time')
    #plt.ylabel('velocity')
    #plt.legend()
    #plt.show()
